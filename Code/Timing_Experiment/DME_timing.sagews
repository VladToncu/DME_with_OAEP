import time
#Setting up the parameters of DME
e = 7;
n = 2;
m = 3;
s = 2;
t = 2;
b = 2;

#Computing the number of monomials that will be generated
mon = (b * n^s)^t
mon2 = b * n^s

#F_q is F_2/{irreducible element in F_2}
F.<r> = GF(2)[];

for p in F.polynomials(e):
    if p.is_irreducible():
        break;

K.<q> = GF(2^e, name='q', modulus=p);

#Zn and Zm is used to generate the elements of matrices A and B
Zn = Integers(2^(e*n)-1);
Zm = Integers(2^(e*m)-1);

R = PolynomialRing(K,'X');
R.inject_variables();

'''
pt_sec2pub is the matrix which contains the 64 plaintext that are used to generate the public key.
M1 is a 64x64 matrix which contains the first 64 monomials of the 64 plaintexts, generated by the function compute_monomials_for_public_key.
M2 is a 64x64 matrix which contains the last 64 monomials of the 64 plaintexts, generated by the function compute_monomials_for_public_key.
M1inv and M2inv are the inverses of M1, respectively M2, which are used to generate the public key.
'''
M1 = matrix(K,mon,mon);
M2 = matrix(K,mon,mon);
M1inv = matrix(K,mon,mon);
M2inv = matrix(K,mon,mon);
pt_sec2pub = matrix(K,mon,m*n);

#Find irreducible polynomial of degree 2 for F_(q^2) in G1
while True:
    IPn = X^n;
    for i in range(0,n):
        a = K.random_element();
        IPn += a * X^(n-1-i);
    if IPn.is_irreducible():
        break;

#Find irreducible polynomial of degree 3 for F_(q^3) in G2
while True:
    IPm = X^m;
    for i in range(0,m):
        a = K.random_element();
        IPm += a * X^(m-1-i);
    if IPm.is_irreducible():
        break;

Rm = PolynomialRing(K,'XXX').quotient(IPm);
Rm.inject_variables();

Rn = PolynomialRing(K,'XX').quotient(IPn);
Rn.inject_variables();

#Generate matrix for L1
while(True):
    L1 = matrix(K,m*n,m*n);
    for i in range(0,m*n):
        for j in range(n*(i//n),n*(i//n)+n):
            L1[i,j] = K.random_element();
    if L1.is_invertible():
        break;

#Apply L1
def applyL1(x):
    return L1*x;

#Generate matrix for L2
while(True):
    L2 = matrix(K,m*n,m*n);
    for i in range(0,m*n):
        for j in range(m*(i//m),m*(i//m)+m):
            L2[i,j] = K.random_element();
    if L2.is_invertible():
        break;

#Apply L2
def applyL2(x):
    return L2*x;

#Generate matrix for L3
while(True):
    L3 = matrix(K,m*n,m*n);
    for i in range(0,m*n):
        for j in range(m*(i//m),m*(i//m)+m):
            L3[i,j] = K.random_element();
    if L3.is_invertible():
        break;

#Apply L3
def applyL3(x):
    return L3*x;

#Constructing matrix A using random elements in Zn, which only allows maximum of s elements per rows to be non-zero
A = matrix(Zn,m,m);
Ainv = matrix(Zn,m,m);
def generateA():
    global A
    global Ainv
    while True:
        for i in range(0,m):
            counterZero = 0
            counterNon = 0
            for j in range(0,m):
                if(counterZero < m-s and counterNon < s):
                    rand_z = ZZ.random_element(0,2)
                    if(rand_z == 0):
                        A[i,j] = 0
                        counterZero += 1
                    else:
                        A[i,j] = 2^(ZZ.random_element(0,n*e));
                        counterNon += 1
                elif(counterZero == m-s):
                    A[i,j] = 2^(ZZ.random_element(0,n*e));
                else:
                    A[i,j] = 0;
        detA = A.determinant();
        if gcd(detA,2^(e*n)-1) == 1:
                break;
    Ainv = A.inverse()

#Constructing matrix B using random elements in Zm, which only allows maximum of t elements per rows to be non-zero
B = matrix(Zm,n,n);
Binv = matrix(Zm,n,n);

def generateB():
    global B
    global Binv
    while True:
        for i in range(0,n):
            counterZero = 0
            counterNon = 0
            for j in range(0,n):
                if(counterZero < n-t and counterNon < t):
                    rand_z = ZZ.random_element(0,2)
                    if(rand_z == 0):
                        B[i,j] = 0
                        counterZero += 1
                    else:
                        B[i,j] = 2^(ZZ.random_element(0,m*e));
                        counterNon += 1
                elif(counterZero == n-t):
                    B[i,j] = 2^(ZZ.random_element(0,m*e));
                else:
                    B[i,j] = 0;
        detB = B.determinant();
        if gcd(detB,2^(e*m)-1) == 1:
                break;
    Binv = B.inverse()

#We generate matrices A and B.
generateA()
generateB()

#Apply G1
def G1(x):

    y = matrix(K,m*n,1);
    vec = matrix(Rn,m,1);
    result = matrix(Rn,m,1);

    for i in range(0,m):
        for j in range(0,n):
            vec[i] += XXbar^(n-1-j) * x[i*n+j];

	#Raising the polynomials to an elements of A will give another polynomial of degree 1 because the polynomial ring that contains them is modulus a polynomial of degree n, IPn.
    for i in range(0,m):
        result[i] = 1
        for j in range(0,m):
            if(A[i][j] != 0):
                result[i]  *=  (vec[j])[0]^(A[i][j]).lift();
    for i in range(0,m):
        for j in range(0,n):
            y[i*n+j] = ((result[i])[0])[n-1-j];

    return y;

#Apply G2
def G2(x):

    y = matrix(K,m*n,1);
    vec = matrix(Rm,n,1);
    result = matrix(Rm,n,1);

    for i in range(0,n):
        for j in range(0,m):
            vec[i] += XXXbar^(m-1-j) * x[i*m+j];

	#Raising the polynomials to an elements of A will give another polynomial of degree 1 because the polynomial ring that contains them is modulus a polynomial of degree m, IPm.
    for i in range(0,n):
        result[i] = 1
        for j in range(0,n):
            if(B[i][j] != 0):
                result[i]  *=  (vec[j])[0]^(B[i][j]).lift();
    for i in range(0,n):
        for j in range(0,m):
            y[i*m+j] = ((result[i])[0])[m-1-j];

    return y;

#Encrypt with secret key
def encrypt_with_secret_key(x):

    #Apply L1
    afterL1 = applyL1(x);

    #Apply G1
    afterG1 = G1(afterL1);

    #Apply L2
    afterL2 = applyL2(afterG1);

    #Apply G2
    afterG2 = G2(afterL2);

    #Apply L3
    encrypted = applyL3(afterG2);

    return encrypted;


#Apply inverse of L3
def inverseL3(x):
    return L3.inverse()*x;

#Apply inverse of L2
def inverseL2(x):
    return L2.inverse()*x;

#Apply inverse of L1
def inverseL1(x):
    return L1.inverse()*x;

#Apply inverse of G2
def inverseG2(x):

    y = matrix(K,m*n,1);
    vec = matrix(Rm,n,1);
    result = matrix(Rm,n,1);
    for i in range(0,n):
        for j in range(0,m):
            vec[i] += XXXbar^(m-1-j) * x[i*m+j];

	#Raising the polynomials to an elements of A will give another polynomial of degree 1 because the polynomial ring that contains them is modulus a polynomial of degree n, IPn.
    for i in range(0,n):
        result[i] = 1
        for j in range(0,n):
            if(Binv[i][j] != 0):
                result[i]  *=  (vec[j])[0]^(Binv[i][j]).lift();
    for i in range(0,n):
        for j in range(0,m):
            y[i*m+j] = ((result[i])[0])[m-1-j];

    return y;

#Apply inverse of G1
def inverseG1(x):

    y = matrix(K,m*n,1);
    vec = matrix(Rn,m,1);
    result = matrix(Rn,m,1);

    for i in range(0,m):
        for j in range(0,n):
            vec[i] += XXbar^(n-1-j) * x[i*n+j];

	#Raising the polynomials to an elements of A will give another polynomial of degree 1 because the polynomial ring that contains them is modulus a polynomial of degree m, IPm.
    for i in range(0,m):
        result[i] = 1
        for j in range(0,m):
            if(Ainv[i][j] != 0):
                result[i]  *=  (vec[j])[0]^(Ainv[i][j]).lift();
    for i in range(0,m):
        for j in range(0,n):
            y[i*n+j] = ((result[i])[0])[n-1-j];

    return y;

#Encrypt with secret key
def decrypt_with_secret_key(x):

    #Apply L3_decrypt
    afterL3Decrypt = inverseL3(x);

    #Apply G2_decrypt
    afterG2Decrypt = inverseG2(afterL3Decrypt);

    #Apply L2_decrypt
    afterL2Decrypt = inverseL2(afterG2Decrypt);

    #Apply G1_decrypt
    afterG1Decrypt = inverseG1(afterL2Decrypt);

    #Apply L1_decrypt
    decrypted = inverseL1(afterG1Decrypt);

    return decrypted;

'''
This computes the monomials generated when one applies G1 and G2 to the input. The generation of these monomials work using the following approach:
    For each row of matrix A, we compute s polynomials: 
        The first polynomial will be x_(j*n)*Y_0+x_(j*n+1) raised to the power of the first non-zero element of A in a specific row and j is the column where that A was found. 
        The second polynomial will be x_(j*n)*Y_1+x_(j*n+1) raised to the power of the second non-zero element of A in a specific row and j is the column where that A was found.
        ...
        Do this until you do not have anymore elements non-zero in a row. You multiply these polynomials and get its coefficients (these will be the monomials generated by G1)
    Do the same for matrix B.
'''
def compute_monomials_for_public_key(x):
    row = matrix(K,ceil(m/b),mon2)
    row_results = matrix(K,m,n^s)
    vector_result = matrix(K,mon*2,1)
    H = PolynomialRing(K,'Y',s)
    c = H.gens()
    for i in range(0,m):
        counterPol = 0
        pol_all = []
        for j in range(0,m):
                if(A[i][j]!=0):
                    pol_all += [(x[j*n][0]^A[i][j].lift())*c[counterPol]+(x[j*n+1][0]^A[i][j].lift())]
                    counterPol += 1
        pol = pol_all[0]*pol_all[1]
        row_results[i]=pol.coefficients()
    for i in range(0,ceil(m/b)):
        for j in range(0,b):
            for k in range(0,n^s):
                row[i,n^s*j+k] = row_results[i*floor(m/b)+j][k]
    for i in range(0,mon2):
        for j in range(0,mon2):
            vector_result[mon2*i + j] = row[0][i] ^ B[0][0].lift() * row[1][j] ^ B[0][1].lift()
            vector_result[mon2*i + j + mon] = row[0][i] ^ B[1][0].lift() * row[1][j] ^ B[1][1].lift()

    return vector_result

'''
Encryption of a plaintext with the public key. You generate the public key and multiply it with the monomials of the plaintext you have as an input. 
The monomials are generated by running compute_monomials_for_public_key using the input text as an argument.
'''
def encrypt_with_public_key(x):

    monomials = matrix(K,mon*2,1);
    monomials1 = matrix(K,mon,1);
    monomials2 = matrix(K,mon,1);
    public_key = getPublicKeyFromSecretKey();
    monomials = compute_monomials_for_public_key(x);
    ciphertext = matrix(K,n*m,1);

	# We are splitting the monomials into 2 sections as outlined in the paper: the ones for the first 3 elements in the input and the ones for the last 3 elements.
    for i in range(0,mon):
        monomials1[i] = monomials[i]
        monomials2[i] = monomials[i+mon]

	# Multiply the monomials generated from G1 and G2 with the public key
    cipher_text_1 = public_key[0] * monomials1
    cipher_text_2 = public_key[1] * monomials2
	# Return the ciphertext
    for i in range(0,m):
        ciphertext[i] = cipher_text_1[i];
        ciphertext[i+m] = cipher_text_2[i];

    return ciphertext

'''
Generating the M1 and M2 matrices. The way in which this is done is by running compute_monomials_for_public_key for each plaintext in the pt_sec2pub to generate its monomials
'''
def generateVectors():

    while True:
        for i in range(0,mon):
            for j in range(0,m*n):
                pt_sec2pub[i,j] = K.random_element();
            transp = matrix(pt_sec2pub[i]).transpose();
            vec_transp = compute_monomials_for_public_key(transp);
            for j in range(0,mon):
                M1[j,i] = vec_transp[j][0];
                M2[j,i] = vec_transp[j+mon][0];
        if M1.is_invertible() & M2.is_invertible():
            break;
        else:
            generateA();
            generateB();

'''
Function for getting the public key. For a fast method of doing so, we are going to use the private key as indicated in the paper. 
We are going to encrypt each vector in pt_sec2pub with the secret key and multiply them with the inverses of M1 and M2. The reason is that:

The coefficients of the elements in pt_sec2pub multiplied with the monomials in M1 and M2 will give the encryption with the secret key of the elements in the pt_sec2pub.
The coefficients are the ones that do not depend on which plaintext you use and as a result, they can be used as the public key. As a result, if one multiplies the 
encryption using the secret key with the inverse of the matrices M1 and M2, one can retrieve the coefficients matrix and use it as a public key.
'''
def getPublicKeyFromSecretKey():

    CT1 = matrix(K,m,mon);
    CT2 = matrix(K,m,mon);
    ct = matrix(K,1,m*n);
    generateVectors();

    for i in range(0,mon):
        line =  matrix(pt_sec2pub[i]).transpose()
        ct = encrypt_with_secret_key(line);
        for j in range(0,m):
		# Split the ciphertext in 2 parts given to multiply each with M1 and M2 inverse
            CT1[j,i] = ct[j][0]
            CT2[j,i] = ct[j+m][0]
    return (CT1*M1.inverse(),CT2*M2.inverse())

sum_of_timing = 0
sum_of_timing_enc = 0
for i in range(0,20):
    test = matrix(K,m*n,1)
    for i in range(0,m*n):
        test[i,0] = K.random_element();

    start_timer_enc = time.time()
    enc_p = encrypt_with_public_key(test)
    end_timer_enc = time.time()
    start_timer_dec = time.time()
    dec_p = decrypt_with_secret_key(enc_p)
    end_timer_dec = time.time()
    sum_of_timing += end_timer_dec - start_timer_dec
    print sum_of_timing
    sum_of_timing_enc += end_timer_enc - start_timer_enc
    print sum_of_timing_enc
print sum_of_timing
print "Mean dec"
print sum_of_timing/20
print sum_of_timing_enc
print "Mean enc"
print sum_of_timing_enc/20









